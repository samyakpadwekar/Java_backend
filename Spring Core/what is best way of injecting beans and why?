#1.All Required Dependencies Are Available at Initialization Time - 
We create an object by calling a constructor. 
If the constructor expects all required dependencies as parameters,then we can be 100% sure that the class will never be instantiated without its dependencies injected.
The IoC container makes sure that all the arguments provided in the constructor are available before passing them into the constructor.
This helps in preventing the infamous NullPointerException.
Constructor injection is extremely useful since we do not have to write separate business logic everywhere to check if all the required dependencies are loaded, 
thus simplifying code complexity.

What About Optional Dependencies?
With setter injection, Spring allows us to specify optional dependencies by adding @Autowired(required = false) to a setter method.
This is not possible with constructor injection since the required=false would be applied to all constructor arguments.
We can still provide optional dependencies with constructor injection using Java's Optional type.

#2.Identifying Code Smells -
Constructor injection helps us to identify if our bean is dependent on too many other objects. 
If our constructor has a large number of arguments this may be a sign that our class has too many responsibilities. 
We may want to think about refactoring our code to better address proper separation of concerns.

#3.Preventing Errors in Tests -
Constructor injection simplifies writing unit tests. 
The constructor forces us to provide valid objects for all dependencies. 
Using mocking libraries like Mockito, we can create mock objects that we can then pass into the constructor.
We can also pass mocks via setters, of course, but if we add a new dependency to a class, we may forget to call the setter in the test, potentially causing a NullPointerException in the test.
Constructor injection ensures that our test cases are executed only when all the dependencies are available. 
It’s not possible to have half created objects in unit tests (or anywhere else for that matter).

#4.Immutability -
Constructor injection helps in creating immutable objects because a constructor’s signature is the only possible way to create objects. 
Once we create a bean, we cannot alter its dependencies anymore. 
With setter injection, it’s possible to inject the dependency after creation, thus leading to mutable objects which, among other things, may not be thread-safe in a multi-threaded environment and are harder to debug due to their mutability.
